<html>
  <head>
    <title>Testing JS timing</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      table{
        border-collapse: collapse;
      }
      button, select, input{
          padding: 5px;
          font-size: 120%;
      }
      th, td{
        border: 1px solid black;
        padding: 10px;
        text-align: center;
      }
      input{
          border: none;
          width: 5em;
      }
      .nopadding{
          padding:0;
      }
      .wide_input{
          width: 15em;
      }
    </style>
    <script>
      const MIN_PAYMENT = 1;
      const NUMB_OF_FIGURES = 0;
      const UNKNOWN = -123456;
      const EMPTY = "empty";
      var numb_of_all = 3;  // Defaults
      var controller = "";

      // A 2d array, works as a cols times rows table
      class Table{
          // Parametres: number of columns and rows:
          constructor(cols, rows){
              this.rows = rows;
              this.cols = cols;
              this.table = this.initiate();
          }
          // Set value to the cell at (x,y). Value x refers to col (width),
          // y to row (height) like in the coordinates system. Note:
          // x and y begin at 1. Cell (1,1) is the top left one (like in a
          // spread sheet program).
          // Return True if success, otherwise False.
          set(value, x, y){
              let success = false;
              if(x > this.cols || y > this.rows){
                  alert("Value too big for the table!");
              } else{
                  this.table[y][x] = value;
                  success = true;
              }
              return success;
          }
          // Returns the value of cell (x,y).
          get(x,y){
              let value = UNKNOWN;
              if(x > this.cols || y > this.rows){
                  alert("Value too big for the table!");
              } else{
                  value = this.table[y][x];
              }
              return value;
          }
          // Initate array with the right sizes:
          initiate(){
              let table = new Array(this.rows);
              for(let i = 0; i < table.length; i++){
                  table[i] = new Array(this.cols);
              }
              return table;
          }
          // Returns an HTML presentation of the table:
          toHTML(){
              let html = "<table>";

              // Rows:
              for(let i = 1; i <= this.rows; i++){
                  html += "<tr>";

                  // a Row (there are as many cols as the rich);
                  for(let k = 1; k <= this.cols; k++){
                      html += "<td>"+this.get(k,i)+"</td>";
                  }
                  html += "</tr>";
              }
              html += "</table>";
              return html;
          }
      }

      class Person{
          constructor(number, name, weight, paid){
              this.number = parseInt(number);
              this.name = name;
              this.weight = parseFloat(weight);
              this.paid = parseFloat(paid);
              this.balance = 0;
          }
      }
      class Controller{
          constructor(){
              this.persons = [];
              this.the_rich = [];
              this.the_poor = [];
              this.payments = [];
              this.total = this.count_total();
              this.weights_total = this.count_weights_total();
              this.vues = new Views();
          }
          // Reads the personal details and returns an array of person objects.
          // If a cell is empty, breaks the loop and gives an error message.
          read_person_info(){
              let persons = [];
              for(let i = 0; i < numb_of_all; i++){
                  let number = (i+1);
                  let name = this.vues.get_elem("name_"+(i+1)).value;
                  if (name === ""){
                      alert("Empty cell found! Fill in first each cell!");
                      break;
                  }
                  let paid = this.vues.get_elem("paid_"+(i+1)).value;
                  if (name === ""){
                      alert("Empty cell found! Fill in first each cell!");
                      break;
                  }
                  let weight = this.vues.get_elem("weight_"+(i+1)).value;
                  if (name === ""){
                      alert("Empty cell found! Fill in first each cell!");
                      break;
                  }
                  let p = new Person(number, name, paid, weight);

                  persons.push(p);
                  alert("Person "+number+": "+name+" has paid "+paid+
                    " euros and has weight "+weight);
              }
              return persons;
          }

          // Counts and returns the sum of all the paid amounts.
          count_total(){
              let persons = this.persons;
              let sum = 0;
              for(let i=0; i < persons.length; i++){
                  sum += persons[i].paid;
              }
              return sum;
          }
          // Counts and returns the sum of all weights.
          // Note: the sum should not zero (division problem).
          // The caller takes care of the checking.
          count_weights_total(){
              let persons = this.persons;
              let sum = 0;
              for(let i=0; i < persons.length; i++){
                  sum += persons[i].paid;
              }
              return sum;
          }
          // Returns an array of two arrays: persons having paid less than their
          // share and another array with all the rest. Divides all the persons into
          // two groups.
          // Also sets the balance of each person telling how much he/she must
          // pay or get from others.
          get_the_rich_and_the_poor(){
              let persons = this.persons;
              let paid_total = this.total;
              let the_poor = [];
              let the_rich = [];
              let total_to_pay_for_person = 0;
              for(let i = 0; i < persons.length; i++){
                  let p = persons[i];
                  total_to_pay_for_person = this.personal_total_by_weight(p);

                  alert("total_to_pay_for_person="+total_to_pay_for_person);

                  // Positive balance -> person must pay to someone. Negative->
                  // someone else ows him that much.
                  p.balance = total_to_pay_for_person - p.paid;

                  // If person must pay -> adds to the persons in debt.
                  if(p.balance > 0){
                      the_poor.push(p);
                  } else{
                      the_rich.push(p);
                  }
              }
              return [the_poor, the_rich];
          }
          // Counts and returns the total to be paid by a person
          personal_total_by_weight(person){
              let pers_total = (this.total / this.weights_total) * person.weight;
              return this.round_to_figures(pers_total, 2);
          }

          // Round to figures figures.
          round_to_figures(number, figures){
              let x = number * Math.pow(10, figures);
              let x_rounded = Math.round(x);
              let final = x_rounded / Math.pow(10, figures);
              return final;
          }

          calculate(){
              // Clears the old values:
              this.clear_results();
              this.persons = this.read_person_info();
              this.total = this.count_total();
              this.weights_total = this.count_weights_total();
              let groups = this.get_the_rich_and_the_poor();
              this.the_poor = groups[0];
              this.the_rich = groups[1];
              this.payments = new Table(this.the_poor.length,this.the_rich.length);

              // Calculate the sum to pay for each poor person. The payment
              // is divided into parts based on the richÍ„s needs.. The sums
              // are written into the payments table (2-dim). The first row
              // like the first col are left empty (for the names).
              let x = 2;
              let y = 2;
              for(let i = 0; i < this.the_poor.length; i++){
                  let payer = this.the_poor[i];
                  for(let k = 0; k < this.the_rich.length; k++){
                      let rich_guy = this.the_rich[k];

                      // Balance must be > or = MIN_PAYMENT for payment need.
                      if(payer.balance < MIN_PAYMENT ||
                          Math.abs(rich_guy.balance < MIN_PAYMENT)){

                            // Nothing to pay:
                          this.payments.set("-",x,y);
                      }
                      // If there is still debt to pay:
                      else if(payer.balance > MIN_PAYMENT){
                          // How much to pay to this rich person?
                          let payment_exact =
                            Math.min(payer.balance, rich_guy.balance);
                          let payment = round_to(payment_exact, NUMB_OF_FIGURES);
                          payer.balance -= payment;
                          rich_guy.balance += payment;
                          this.payments.set(payment,x,y);
                      }
                      // One step to the right: the next rich guy:
                      x++;
                  }
                  // New payer (one step down in the table):
                  y++;
                  // Jump to the column 2 (the 1st rich guy):
                  x = 2;
              }
              this.vues.set_content("result", this.payments.toHTML());
          }
          // Add the names to the payments table (the rich row 1, the poor column 1)
          write_names_to_table(){
              let poor = "";
              let rich = "";
              for(let i = 0; i < this.the_poor.length; i++){
                  poor = this.the_poor[i];
                  this.payments.set(poor.name,1,i+1);
              }
              for(let j = 0; j < this.the_rich.length; j++){
                  rich = this.the_rich[j];
                  this.payments.set(rich.name,j+1,1);
              }
          }
          clear_results(){
              this.vues.get_elem("result").innerHTML = "";
          }
      }
      class Views{
          constructor(){

          }
          make_infotable(numb){
              let html = "<table id='persons_table'>";
              html += "<tr><th></th><th>Name</th><th>Paid</th><th>Weight (%)</th></tr>";
              let index = 0;
              for(var i = 0; i < numb; i++){
                  index++;
                  html += "<tr><td>Person "+index+"</td>"+
                    "<td class='nopadding'>"+
                        "<input class='wide_input' id='name_"+index+"' type='text'>"+
                    "</td>"+
                    "<td class='nopadding'>"+
                        "<input id='paid_"+index+"' type='text'>"+
                    "</td>"+
                    "<td class='nopadding'>"+
                        "<input id='weight_"+index+"' type='text'>"+
                    "</td>"+
                    "</tr>";
              }
              html += "</table>";
              return html;
          }
          show_table(){
              let numb = this.get_elem("numb_of_all").value;
              numb_of_all = numb;
              let tbl = this.make_infotable(numb);
              this.set_content("persons",tbl);
          }
          // General help methods to handle HTML and DOM
          get_elem(id){
              return document.getElementById(id);
          }
          set_content(id,content){
              let elem = this.get_elem(id);
              if(elem){
                  elem.innerHTML = content;
              } else {
                  alert("No elem found with id="+id);
              }
          }
          // Helps with many similar options:
          add_option_elem(val, def){
              var selected = "";
              if (val === def){
                  selected = 'selected="selected"';
              }
              return '<option value="'+val+'" '+selected+'>'+val+'</option>';
          }

          // Options with numbers 1-number:
          create_option_elems(number, def){
              var options_html = "";
              for(var i = 0; i < number; i++){
                  options_html += this.add_option_elem(i+1,def);
              }
              return options_html;
          }
      }

      function init(){
          controller = new Controller();
          let vues = controller.vues;
          let numb = numb_of_all;
          let tbl = vues.make_infotable(numb);
          vues.set_content("persons",tbl);
      }


    </script>
  </head>
  <body onload="init()">
    <h1>Bill Solver</h1>
    <p id="guide">This application makes it easy to know how much each ows who.</p>
    <p id="question_number">
      <label for="numb_of_all">How many participated?</label>
      <select id="numb_of_all" onchange="controller.vues.show_table(this.value)">
        <script>
          vue = new Views(); // Seems to run before init()!
          document.write(vue.create_option_elems(100, 3))
        </script>
      </select>
      <!--<button onclick="show_table()">Show table</button>-->

    </p>
    <p><button onclick="controller.calculate()">Solve it</button></p>
    <div id="persons"></div>
    <div id="result"></div>
    <script>

    </script>

  </body>
</html>
